<html>
     <head>
          <title>Flask app</title>
          <link rel="stylesheet" href="./static/css/style.css">
     </head>
     <body>
       ADD HLJS
       <h1> Typescript </h1> <Br> <br> <br>


       <h2> Typescript </h2> <hr>
       <b>1. Is a superset of JS</b> <br>
       This means it incorporates all the features of JS, while adding its own <br> <br>

       <b>2. Compiles into JS </b> <br>
       A typescript file will compile into a plain JS file. <br> <br>

       <h2> Typing </h2> <hr>
        One of the primary features of typescript is that it is: <br> <br>

        0. <b>strongly typed</b>: errors are thrown if you try to perform an implicit conversion <br>
        1. <b>statically typed</b>: typechecks are done at compile-time, rather than runtime <br> <br> <br>

        Let's look at an example of what this looks like. If you have the following typescript file <code>example.ts</code>:
        <pre> <code>
            var x:number = 15;
        </code> </pre>
        And compile with <code> tsc example.ts </code>, you would get an <code>example.js</code> file that looked like this:
        <pre> <code>
            var x = 15;
        </code> </pre>
        But if you tried to re-assign x to a different type like so:
        <pre> <code>
            var x:number = 15;
            x = 'hello';
        </code> </pre>
        You would get the following compiler error:
        <pre> <code>
        example.ts:2:1 - error TS2322: Type '"hello"' is not assignable to type 'number'.

        2 x = 'hello';
          ~


        Found 1 error.
      </code> </pre> <br>

      Note that the error occured in the second case because we tried to convert from a number to a string. <br> <br>
      Function parameters and return values are also typed in typescript. So if we have the following:

      <pre> <code>
          var x:number = 15;
          var y:string = '25';

          function distance_from_origin(x: number, y:number) : number {
            return Math.sqrt(x*x + y*y);
          }

          distance_from_origin(x, y);
      </code> </pre> <br>

      We would get a compiler error for attempting to call this function with paramenter <code>y</code> being a string. <br> <BR>

      The basic types in typescript are:
      <ul>
      <li>number</li>
      <li>boolean</li>
      <li>string</li> <br>
    </ul> Note two things: <br>
      One, the lack of ints or doubles: there is only a single number type. <br>
      Also, note that these types exist in JS too, but conversions are so fluid that it can be easy to forget <br>
      that variables in base JS do have types.



       <h3> Benefits of typing </h3>
       - catch errors earlier and easier <br>
       - self documenting <br>
       - easy to re-factor (change insides of function without changing external behavior) <br>

       <h3> Editor support </h3> <hr>
       Most editors have added support for typescript which includes, among other things:
       <ul>
       <li>automatic compilation on save</li>
       <li>type error highlighting</li>
       <li>autocomplete</li>
       <li>function headers and variable types on scroll-over</li>
     </ul> <br>
       Click this link to see a list of compiler add-ons for the most popular editors. <br>


       <h2> Enums </h2> <hr>
       As I stated above, typescript is a superscript of JS, meaning it has some features that JS does <br>
       not support. One of these is enums. <br> <br>

       Enums are a way to avoid 'magic numbers' in your programs. Here's an example:

       <pre> <code>
       Enum shapes {
         square = 0;
         circle = 1;
         rectangle = 2;
       }
     </pre> </code> <br>

       If we then tried console.log(shapes.square), we would get 0. The enum makes it so that <br>
       shapes.square has a value of 0. So in our code we could write <br>
       something like
       <pre> <code>
         if (input == shapes.square) {
           // do stuff
         }
       </pre> </code>
       Where shapes.square is synonymous with 0. However, this is far easier to read and understand than
       <pre> <code>
         if (input == 0) {
           // do stuff
         }
       </pre> </code>

       <h2> Type Inferencing </h2> <hr>
       While typescript's typing system is great, it can be a bit cumbersome at times. This is why <br>
       typescript includes type inferecing! Let's modify the prior example a bit:

       <pre> <code>

       </pre> </code>
       <h2> Type Optional </h2> <hr>
       <h2> Generics </h2> <hr>
       <h2> Classes </h2> <hr>
       <h2> Benefits of compiler and tsconfig.json </h2> <hr>





          One benefit of the compiler is that it allows us to catch errors at compile-time <br>
          rather than at runtime.

          There are also other benefits to typescript's typing. When trying
          <pre> <code>
              [] + []
              [] + {}
              {} + []
              {} + {}
          </code> </pre>
          Typescript's compiler will throw the following error messages:
          <pre> <code>
              example.ts:1:13 - error TS2365: Operator '+' cannot be applied to types 'undefined[]' and 'undefined[]'.

              1 console.log([] + []);
                          ~~~~~~~

              example.ts:2:13 - error TS2365: Operator '+' cannot be applied to types 'undefined[]' and '{}'.

              2 console.log([] + {});
                          ~~~~~~~

              example.ts:3:13 - error TS2365: Operator '+' cannot be applied to types '{}' and 'undefined[]'.

              3 console.log({} + []);
                          ~~~~~~~

              example.ts:4:13 - error TS2365: Operator '+' cannot be applied to types '{}' and '{}'.

              4 console.log({} + {});
                          ~~~~~~~


              Found 4 errors.
          </code> </pre> <br> <br>

          One of the best things about typescript is that its typing is completely optional. <br>
          You can give any variable the 'any' type, and it will not give a compiler error for <br>
          changing types like so: <br>
          <pre> <code>
              var x:any = 15;
              var x = 'hello'
          </code> </pre>
          Another great thing about typescript is that it can infer types. If you had the following: <br>
          <pre> <code>
              var x = 15;
              var x = 'hello'
          </code> </pre>
          It would throw the same compiler error as if you had explicitly typed <code>x</code> to be a number. <br> <br>

          For large projects, typescript's compiler provides a lot of utility because it allows you to <br>
          combine many files into one. <br>

          Now let's talk about classes and what typescript does for them, like readonly properties and explicit property declaration. <br> <br>


          This also means that you can sometimes leave out the return types of functions. <br> <br>
          Thanks for listening! If you did listen, that is. Navigate to <a href = "http://www.typescriptlang.org/">http://www.typescriptlang.org/</a><br>
          for more info and also to learn how to download typescript.
          <script src = "{{ url_for('static', filename='script.js') }}"> </script>
     </body>
</html>
